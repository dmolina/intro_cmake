#+TITLE: CMake: Compilando en C/C++ f치cilmente
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
# +REVEAL_THEME: white
#+REVEAL_EXTRA_CSS: style_simple.css
#+AUTHOR: Daniel Molina Cabrera
#+DATE: dmolina@decsai.ugr.es
#+OPTIONS: toc:nil ^:nil num:nil

* Necesidad de CMake

** El uso de Makefile es deseable

- Compilar s칩lo los ficheros cambiados es deseable. 
  + Compilaci칩n puede ser muy larga.

- Es necesario formato independiente del IDE. 

  + Cada uno use el IDE que prefiera.

- Facilitar la instalaci칩n.

** Los makefiles presentan muchos problemas

- Compilar un simple programa supone muchas l칤neas.

- No es intuitivo. 

- Es dif칤cil que sea multiplataforma.

** 쯈ue hac칠is los alumnos?

#+ATTR_REVEAL: :frag (roll-in)
- Dejarlos para el final 游.

- No poner dependencias, o un /bash/ 游땮.

- No usarlo, compilar /a mano/ 游땯. 

** Los makefiles pueden generalizarse

#+BEGIN_SRC make
CC=g++
CFLAGS=-Wall
EXEC = main
DEPS = polinomio.h
SOURCES = $(shell ls *.cpp)
OBJS = $(SOURCES:%.cpp=%.o)

$(EXEC): $(OBJS)
	$(CC) $(CFLAGS) -o $(EXEC) $(OBJS)

%.o: %.cpp $(DEPS)
	$(CC) $(CFLAGS) -c $< -o $@

.PHONY: clean

clean:
	rm *.o $(EXEC)

#+END_SRC

** Procedimiento /usual/

1. Buscar makefile de otro proyecto. 

2. Adaptar las variables. 

#+ATTR_REVEAL: :frag (roll-in)
No es trivial, no resuelve:

#+ATTR_REVEAL: :frag (roll-in)
- Adaptar distintos entornos. 
- Dependencias complejas.

** 쯏 las librer칤as?

- No se puede comprobar f치cilmente si est치n. 

- Crear librer칤as es a칰n m치s complejo. 

- Complicado crear tanto librer칤as como programas.

* Alternativa: CMake

** Qu칠 es CMake

- Un programa que genera Makefiles por nosotros. 

- Dise침ado para ser *portable*.

- Mucho m치s f치cil de usar. 


** Ventajas

- M치s portable.

- Mucho m치s sencillo en casos no complejos. 

- Muy buen soporte de librer칤as.

** Desventajas de CMake

- *Dependencia*: Requiere para compilar:
  + Make.
  + Compilador. 
  + CMake.

- Sintaxis algo compleja para opciones m치s complejas. 

- Nuevas versiones menos intuitivas.

* Usando CMake

** Proceso

#+ATTR_REVEAL: :frag (roll-in)
1. Crear fichero *CMakeLists.txt*
2. /cmake ./
3. /make/

#+ATTR_REVEAL: :frag (roll-in)
Tras editar s칩lo hay que volver a ejecutar make. 

** Ventajas del make creado

- Porcentaje de compilaci칩n.

#+BEGIN_EXPORT html
<pre><font color="#8AE234"><b>daniel@ubuntu</b></font>:<font color="#729FCF"><b>~/current/borra/librealea/realea</b></font>$ make
<font color="#AD7FA8"><b>Scanning dependencies of target realea</b></font>
[  1%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/signal.o</font>
[  2%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/running.o</font>
[  3%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/random.o</font>
[  3%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/srandom.o</font>
[  4%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/orandom.o</font>
[  5%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/domain.o</font>
[  6%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/config.o</font>
[  7%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/debug.o</font>
[  8%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/ConfigFile.o</font>
[  9%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/problem.o</font>
In file included from <b>/mnt/home/daniel/current/borra/librealea/realea/common/problem.cc:20:0</b>:
<b>/mnt/home/daniel/current/borra/librealea/realea/common/problem.h:190:9:</b> <font color="#AD7FA8"><b>warning: </b></font>&apos;<b>template&lt;class&gt; class std::auto_ptr</b>&apos; is deprecated [<font color="#AD7FA8"><b>-Wdeprecated-declarations</b></font>]
 typedef <font color="#AD7FA8"><b>auto_ptr</b></font>&lt;Problem&gt; ProblemPtr;
         <font color="#AD7FA8"><b>^~~~~~~~</b></font>
In file included from <b>/mnt/home/daniel/Descargas/tools/anaconda3/x86_64-conda_cos6-linux-gnu/include/c++/7.2.0/memory:80:0</b>,
                 from <b>/mnt/home/daniel/current/borra/librealea/realea/common/problem.h:31</b>,
                 from <b>/mnt/home/daniel/current/borra/librealea/realea/common/problem.cc:20</b>:
<b>/mnt/home/daniel/Descargas/tools/anaconda3/x86_64-conda_cos6-linux-gnu/include/c++/7.2.0/bits/unique_ptr.h:51:28:</b> <font color="#34E2E2"><b>note: </b></font>declared here
   template&lt;typename&gt; class <font color="#34E2E2"><b>auto_ptr</b></font>;
                            <font color="#34E2E2"><b>^~~~~~~~</b></font>
[ 10%] <font color="#4E9A06">Building CXX object common/CMakeFiles/realea.dir/problemtablefactory.o</font>
</pre>
#+END_EXPORT

#+REVEAL: split

- m칰ltiples opciones: 

  - /make help/ : muestra opciones.
  - /make clean/: borra todos los ficheros compilados. 
  - /make install/ (librer칤as, requiere configuraci칩n).

** Depuraci칩n o Release

- *Modo Release*: Optimizado (por defecto).

#+BEGIN_SRC sh
cmake -DCMAKE_BUILD_TYPE=Release .
#+END_SRC

- *Modo debug*: Depurar. 

#+BEGIN_SRC sh
cmake -DCMAKE_BUILD_TYPE=Debug .
#+END_SRC

#+attr_reveal: frag (roll-in)
*Sin cambiar* CMakeLists.txt. 

** Trucos 칰tiles

- Se puede mostrar las opciones del compilador.

#+BEGIN_SRC sh
make VERBOSE=1 
#+END_SRC

- Cambiar el compilador

#+BEGIN_SRC sh
export CC=clang; export CXX=clang++; cmake .
#+END_SRC

* Creando nuestro proyecto CMake

** Crear fichero CMakeLists.txt

Se divide en:

- Definir proyecto (y lenguaje). 
- Definir Variables.
- Definir d칩nde localizar las cosas (.h, libs). 
- Definir ejecutable. 
- Definir librer칤as. 
- Buscar librer칤as.
- Para cada ejecutable definir sus dependencias. 

Todas las opciones son opcionales.

** Hello world

#+BEGIN_SRC sh
PROJECT(hello)
ADD_EXECUTABLE(hello hello.cc)
TARGET_LINK_LIBRARIES(hello)
#+END_SRC

No es t치n dif칤cil.

** Compilando ejecutable

La sintaxis es sencilla:

#+BEGIN_SRC sh
ADD_EXECUTABLE(<nombre_ejecutable> <fichero1> <fichero2> ...)
#+END_SRC

Desde un 칰nico fichero:

#+BEGIN_SRC sh
ADD_EXECUTABLE(ejemplo examplemain.cc)
#+END_SRC

o varios 

#+BEGIN_SRC sh
ADD_EXECUTABLE(programa main.cc board.cc game.cc)
#+END_SRC

Los ficheros .h no se incluye, los detecta s칩lo.

** Variables

Como es pesado definir ficheros, se suelen usar variables.

#+BEGIN_SRC sh
SET(SRC file1.cpp file2.cpp ...)
ADD_EXECUTABLE(exec main.cpp ${SRC})
ADD_EXECUTABLE(test maintest.cpp ${SRC})
#+END_SRC

** Est치ndar de C++

Quiero definir la versi칩n del C++ a compilar, 쯖칩mo lo hago?

#+attr_reveal: frag (roll-in)
#+BEGIN_SRC sh
set(CMAKE_CXX_STANDARD 11)
#+END_SRC

Se puede poner 11, 14 칩 17.

** Versiones de CMake

- Hay opciones, como las anteriores, que son m치s modernas. 

- Se puede indicar una versi칩n m칤nima de CMake. 

#+BEGIN_SRC sh
cmake_minimum_required(VERSION 3.2)
#+END_SRC

** Dependencias con librer칤as

Si tuvi칠semos que enlazar con la librer칤a "libpng.so", 
el 칰nico cambio es:

#+BEGIN_SRC sh
TARGET_LINK_LIBRARIES(hello png)
#+END_SRC

*TARGET_LINK_LIBRARIES* lista las librer칤as con las que compilar.

** Encontrando ficheros .h

- Busca en directorios por defecto. 

- Se puede indicar otro directorios a침adiendo *INCLUDE_DIRECTORIES*:

#+BEGIN_SRC sh
INCLUDE_DIRECTORIES(..)
#+END_SRC

(El directorio actual ya est치 inclu칤do)

** Encontrando librer칤as

- Busca en directorios por defecto. 

- Se puede indicar otro directorios a침adiendo *LINK_DIRECTORIES*:

#+BEGIN_SRC sh
LINK_DIRECTORIES(realea/lib ea/lib localsearch)
#+END_SRC

** Creando librer칤a

Es *igual* que un ejecutable. 

#+BEGIN_SRC sh
ADD_LIBRARY(<libname> SHARED <fichero1> <fichero2>..)
#+END_SRC

- Se usa *SHARED* para librer칤a din치mica, *STATIC* para est치ticas. 

- A침adir치 "lib" al nombre de la librer칤a.

- Se pueden usar variables.

#+BEGIN_SRC sh
ADD_LIBRARY(ea SHARED ${SRC})
#+END_SRC

Crear치 la librer칤a /libea.so/ con esas dependencias. 

** Creaci칩n conjunta de librer칤a y ejecutable

- Es muy f치cil de hacer:

#+BEGIN_SRC sh
ADD_LIBRARY(ea SHARED ${SRC})
ADD_EXECUTABLE(test main.cc)
TARGET_LINK_LIBRARIES(test sfml-windows sfml-graphics ea)
#+END_SRC

#+attr_reveal: frag (roll-in)
Nunca fue m치s f치cil. 

#+attr_reveal: frag (roll-in)
Esto en Make es muy complejo:

* Algunos ejemplos

** Ejemplo real pero corto

#+BEGIN_SRC sh
cmake_minimum_required(VERSION 3.2)
set(CMAKE_CXX_STANDARD 11)
PROJECT(snake)
SET(SRC snake board utils)
ADD_EXECUTABLE(snake snake.cpp ${SRC})
TARGET_LINK_LIBRARIES(snake csfml-window csfml-graphics csfml-system stdc++)
#+END_SRC

** A침adiendo make doc (uso doxygen)

#+BEGIN_SRC sh
INCLUDE(FindDoxygen)

IF(DOXYGEN_EXECUTABLE)
MESSAGE( STATUS "Setting Doxygen Generator" )
ADD_CUSTOM_TARGET(
doc
COMMAND ${DOXYGEN_EXECUTABLE} 
VERBATIM)
ENDIF(DOXYGEN_EXECUTABLE)
#+END_SRC


** Creando librer칤a y ejecutable

#+BEGIN_SRC sh
SET (SRC
hybrid2ph
hybrid
malschains
selectlsimp
get_util
)

INCLUDE_DIRECTORIES(..)
LINK_DIRECTORIES(../lib)
SET (EA malschains)
ADD_LIBRARY(${EA} SHARED ${SRC})
ADD_EXECUTABLE(${EA}_example main_${EA}_example)
TARGET_LINK_LIBRARIES(${EA}_example realea ${EA} ${GlobalEA} realls realpeasy newmat)
#+END_SRC

* En conclusi칩n

** 
[[file:life.png]]
